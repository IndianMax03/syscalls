# Лабораторная работа №2 по дисциплине "Операционные системы"

## Техническое задание

Разработать комплекс программ на пользовательском уровне и уровне ярда, который собирает информацию на стороне ядра и передает информацию на уровень пользователя, и выводит ее в удобном для чтения человеком виде. Программа на уровне пользователя получает на вход аргумент(ы) командной строки (не адрес!), позволяющие идентифицировать из системных таблиц необходимый путь до целевой структуры, осуществляет передачу на уровень ядра, получает информацию из данной структуры и распечатывает структуру в стандартный вывод. Загружаемый модуль ядра принимает запрос через указанный в задании интерфейс, определяет путь до целевой структуры по переданному запросу и возвращает результат на уровень пользователя.

Интерфейс передачи между программой пользователя и ядром и целевая структура задается преподавателем. Интерфейс передачи может быть один из следующих:

1. **syscall - интерфейс системных вызовов.**
    - syscall: thread_struct, vm_area_struct
1. ioctl - передача параметров через управляющий вызов к файлу/устройству.
1. procfs - файловая система /proc, передача параметров через запись в файл.
1. debugfs - отладочная файловая система /sys/kernel/debug, передача параметров через запись в файл.

Целевая структура может быть задана двумя способами:

1. Именем структуры в заголовочных файлах Linux
1. Файлом в каталоге /proc. В этом случае необходимо определить целевую структуру по пути файла в /proc и выводимым данным.

## Реализация

### thread_struct

Поскольку, вся информация о структуре потока [была перенесена](https://elixir.bootlin.com/linux/v6.2.1/source/arch/alpha/include/asm/processor.h#L30) из `thread_struct` в `thread_info`, обратимся к структуре `thread_info`:

Объявление структуры доступно в [заголовочном файле](https://elixir.bootlin.com/linux/v6.2.1/source/arch/alpha/include/asm/thread_info.h#L15):

```C
struct thread_info {
	struct pcb_struct	pcb;		/* palcode state */

	struct task_struct	*task;		/* main task structure */
	unsigned int		flags;		/* low level flags */
	unsigned int		ieee_state;	/* see fpu.h */

	unsigned		cpu;		/* current CPU */
	int			preempt_count; /* 0 => preemptable, <0 => BUG */
	unsigned int		status;		/* thread-synchronous flags */

	int bpt_nsaved;
	unsigned long bpt_addr[2];		/* breakpoint handling  */
	unsigned int bpt_insn[2];
};
```

## Автор

> Тучков Максим Русланович

## Преподаватель практики

> Осипов Святослав Владимирович

## Лектор

> Клименков Сергей Викторович
